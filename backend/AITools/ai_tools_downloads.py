# ===============================================
# ai_tools_downloads.py (Unified Downloads Router)
# ===============================================

from fastapi import APIRouter, Query
from fastapi.responses import FileResponse, JSONResponse
import geopandas as gpd
import tempfile, os, json, zipfile, urllib.parse, shutil

from db import get_user_database_session
from AITools.ai_utils import get_provincial_code_from_schema

router = APIRouter()

# ------------------------------------------------------------
# ðŸ”½ 1. GENERIC FILE DOWNLOAD (works for LR / RF / XGB / any)
# ------------------------------------------------------------
@router.get("/download")
async def ai_download(
    file: str = Query(..., description="Absolute path from the export folder")
):
    try:
        if not os.path.exists(file):
            return JSONResponse(status_code=404, content={"error": "File not found"})

        filename = os.path.basename(file)
        return FileResponse(path=file, filename=filename)
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})


# ------------------------------------------------------------
# ðŸ”½ 2. READ PREDICTED TABLE FROM DB (GeoJSON)
# ------------------------------------------------------------
@router.get("/predicted-geojson")
def ai_predicted_geojson(
    table: str = "Predicted_Output",
    schema: str = "public",
):
    """
    Works for all models â€” LR / RF / XGB models that save predicted tables.
    """
    try:
        provincial_code = get_provincial_code_from_schema(schema)
        db_session = get_user_database_session(provincial_code)
        engine = db_session.get_bind()

        sql = f'SELECT * FROM "{schema}"."{table}"'
        gdf = gpd.read_postgis(sql, engine, geom_col="geometry")

        # CRS fix to WGS84
        if gdf.crs is None:
            gdf = gdf.set_crs(epsg=4326)
        elif gdf.crs.to_epsg() != 4326:
            gdf = gdf.to_crs(epsg=4326)

        engine.dispose()
        db_session.close()
        return json.loads(gdf.to_json())

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})


# ------------------------------------------------------------
# ðŸ”½ 3. SAVE SHAPEFILE ZIP INTO DATABASE
# ------------------------------------------------------------
@router.post("/save-to-db")
async def ai_save_to_db(payload: dict):
    """
    Saves shapefile ZIP (generated by any model) into PostGIS.
    Expected payload:
    {
       shapefile_url: "/api/ai-tools/download?file=C:/path/to/zip",
       table_name: "Predicted_Output",
       schema: "public"
    }
    """
    shapefile_url = payload.get("shapefile_url")
    table_name = payload.get("table_name", "Predicted_Output")
    schema = payload.get("schema", "public")

    if not shapefile_url or not shapefile_url.endswith(".zip"):
        return JSONResponse(status_code=400, content={"error": "Invalid shapefile URL."})

    try:
        decoded = urllib.parse.unquote(shapefile_url)
        file_path = decoded.split("file=")[-1] if "file=" in decoded else decoded

        if not os.path.exists(file_path):
            return JSONResponse(status_code=404, content={"error": f"ZIP not found: {file_path}"})

        # Extract ZIP
        with tempfile.TemporaryDirectory() as tmpdir:
            with zipfile.ZipFile(file_path, "r") as z:
                z.extractall(tmpdir)

            # Find shapefile
            shp_candidates = [
                os.path.join(root, f)
                for root, _, files in os.walk(tmpdir)
                for f in files
                if f.lower().endswith(".shp")
            ]
            if not shp_candidates:
                return JSONResponse(status_code=400, content={"error": "ZIP contains no .shp"})

            shp_path = shp_candidates[0]

            # Read + reproject
            gdf = gpd.read_file(shp_path)
            if gdf.crs:
                if gdf.crs.to_epsg() != 4326:
                    gdf = gdf.to_crs(epsg=4326)
            else:
                gdf = gdf.set_crs(epsg=4326)

            # Save to DB
            provincial_code = get_provincial_code_from_schema(schema)
            db_session = get_user_database_session(provincial_code)
            engine = db_session.get_bind()

            gdf.to_postgis(
                name=table_name,
                con=engine,
                schema=schema,
                if_exists="replace",
                index=False,
            )

            engine.dispose()
            db_session.close()

        return {
            "message": f"Saved successfully to {schema}.{table_name}",
            "schema": schema,
            "table": table_name,
        }

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})


# ------------------------------------------------------------
# ðŸ”½ 4. PREVIEW GEOJSON FROM ZIP SHAPEFILE
# ------------------------------------------------------------
@router.get("/preview-geojson")
async def ai_preview_geojson(
    file_path: str = Query(..., description="Absolute path to exported ZIP")
):
    """
    Works with:
        /api/ai-tools/preview-geojson?file_path=C:/export/.../predicted.zip
    """
    try:
        # Normalize path
        file_path = urllib.parse.unquote(file_path)

        if not os.path.exists(file_path):
            return JSONResponse(status_code=404, content={"error": "File not found"})

        # Case ZIP â†’ extract
        if file_path.lower().endswith(".zip"):
            tmpdir = tempfile.mkdtemp()
            with zipfile.ZipFile(file_path, "r") as z:
                z.extractall(tmpdir)

            shp_candidates = [
                os.path.join(tmpdir, f)
                for f in os.listdir(tmpdir)
                if f.lower().endswith(".shp")
            ]

            if not shp_candidates:
                shutil.rmtree(tmpdir, ignore_errors=True)
                return JSONResponse(status_code=400, content={"error": "No .shp inside ZIP"})

            file_path = shp_candidates[0]

        # Read shapefile â†’ GeoJSON
        gdf = gpd.read_file(file_path)

        if gdf.crs:
            if gdf.crs.to_epsg() != 4326:
                gdf = gdf.to_crs(epsg=4326)
        else:
            gdf = gdf.set_crs(epsg=4326)

        geojson_data = json.loads(gdf.to_json())
        return geojson_data

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})
